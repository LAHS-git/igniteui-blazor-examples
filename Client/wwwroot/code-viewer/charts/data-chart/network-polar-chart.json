{
 "sampleFiles":
[
  {
    "hasRelativeAssetsUrls": false,
    "path": "../../samples/charts/data-chart/network-polar-chart/App.razor",
    "content": "\n@using IgniteUI.Blazor.Controls\n\n<div class=\"container vertical\">\n    <div class=\"options vertical\">\n        <span class=\"legend-title\">Network Polar Chart</span>\n        <div class=\"legend\">\n            <IgbLegend @ref=\"Legend\" Orientation=\"LegendOrientation.Horizontal\" />\n        </div>\n    </div>\n    <div class=\"container vertical\">\n\n        @if (PolarMarkers != null && this.PolarMarkersByLevel != null)\n        {\n        <IgbDataChart Height=\"100%\" Width=\"100%\" @ref=\"Chart\"\n                   SeriesMouseEnterScript=\"onNetworkPolarChartMouseEnter\"\n                   IsHorizontalZoomEnabled=\"false\"\n                   IsVerticalZoomEnabled=\"false\">\n\n            <IgbNumericAngleAxis Name=\"angleAxis\"\n                              MinimumValue=\"0\" MaximumValue=\"360\" Interval=\"30\"\n                              StartAngleOffset=\"270\"\n                              LabelExtent=\"30\"/>\n            <IgbNumericRadiusAxis Name=\"radiusAxis\"\n                               RadiusExtentScale=\"0.85\"\n                               InnerRadiusExtentScale=\"0\"\n                               MinimumValue=\"0\" MaximumValue=\"3\" Interval=\"1\"\n                               CrossingValue=\"-20\"\n                               StrokeThickness=\"0\"\n                               LabelLeftMargin=\"10\"/>\n\n            <IgbPolarLineSeries DataSource=\"PolarConnections\"\n                             AngleAxisName=\"angleAxis\"\n                             AngleMemberPath=\"Angle\"\n                             RadiusAxisName=\"radiusAxis\"\n                             RadiusMemberPath=\"Level\"\n                             ShowDefaultTooltip=\"true\"\n                             Thickness=\"2\"\n                             Brush=\"#676666\"\n                             Title=\"Connections\"\n                             MarkerType=\"MarkerType.None\" />\n\n                @foreach (var markers in this.PolarMarkersByLevel.Values)\n                {\n                    <IgbPolarScatterSeries DataSource=\"@markers\"\n                                        AngleAxisName=\"angleAxis\"\n                                        AngleMemberPath=\"Angle\"\n                                        RadiusAxisName=\"radiusAxis\"\n                                        RadiusMemberPath=\"Level\"\n                                        Thickness=\"1\"\n                                        MarkerType=\"MarkerType.None\"\n                                        MarkerTemplateScript=\"onNetworkPolarChartMarker\"\n                                        Title=\"@(\"Level \" + markers[0].Level)\"\n                                        Brush=\"@markers[0].Fill\"\n                                        Outline=\"@markers[0].Outline\"/>\n                }\n        </IgbDataChart>\n        }\n\n    </div>\n</div>\n\n@code {\n\n    private IgbLegend Legend;\n    private IgbDataChart Chart;\n\n    private List<PolarMarker> PolarConnections;\n    private List<PolarMarker> PolarMarkers;\n    private Dictionary<double, List<PolarMarker>> PolarMarkersByLevel;\n    private Dictionary<double, string> ColorMapping;\n\n    protected override void OnInitialized()\n    {\n\n        // defining data structure of tree nodes\n        var rootNode = new TreeNode { Label = \"0\", Children =\n            {\n                new TreeNode { Label = \"A\", Children =\n                {\n                    new TreeNode { Label = \"A1\" },\n                    new TreeNode { Label = \"A2\" },\n                    new TreeNode { Label = \"A3\" },\n                }},\n                new TreeNode { Label = \"B\", Children =\n                {\n                     new TreeNode { Label = \"B1\" },\n                     new TreeNode { Label = \"B2\" },\n                }},\n                new TreeNode { Label = \"C\", Children =\n                {\n                     new TreeNode { Label = \"C1\" },\n                     new TreeNode { Label = \"C2\" },\n                     new TreeNode { Label = \"C3\" },\n                }},\n                new TreeNode { Label = \"D\", Children =\n                {\n                     new TreeNode { Label = \"D1\" },\n                     new TreeNode { Label = \"D2\" },\n                }},\n                new TreeNode { Label = \"E\", Children =\n                {\n                     new TreeNode { Label = \"E1\" },\n                     new TreeNode { Label = \"E2\" },\n                     new TreeNode { Label = \"E3\" },\n                }},\n            }\n        };\n\n        // defining extra nodes for all outter nodes\n        var leaf = 1;\n        foreach (var inner in rootNode.Children)\n        {\n            foreach (var outter in inner.Children)\n            {\n                for (int i = 0; i < 2; i++)\n                {\n                    var node = new TreeNode { Label = \"\" + leaf++ };\n                    outter.Children.Add(node);\n                }\n            }\n        }\n\n        ColorMapping = new Dictionary<double, string>();\n        ColorMapping.Add(0.0, \"#545353\");\n        ColorMapping.Add(1.0, \"#A532E1\");\n        ColorMapping.Add(2.0, \"#147DD1\");\n        ColorMapping.Add(3.0, \"#1DA31D\");\n\n        // generating polar markers that will represent all tree nodes\n        this.PolarMarkers = new List<PolarMarker>();\n        this.PolarConnections = new List<PolarMarker>();\n\n        var rootMarker = new PolarMarker { Label = \"X\" };\n        rootMarker.Angle = 0;\n        rootMarker.Level = 0;\n        rootMarker.Fill = ColorMapping[rootMarker.Level];\n        this.PolarMarkers.Add(rootMarker);\n\n        double interval = 360 / rootNode.Children.Count;\n        double angle = interval - (180 / rootNode.Children.Count);\n\n        for (int i = 0; i < rootNode.Children.Count; i++)\n        {\n            var step = i * interval;\n            var innerNode = rootNode.Children[i];\n            var innerMarker = new PolarMarker { Label = innerNode.Label };\n            innerMarker.Angle = angle + step;\n            innerMarker.Level = 1;\n            innerMarker.Fill = ColorMapping[innerMarker.Level];\n            this.PolarMarkers.Add(innerMarker);\n\n            this.PolarConnections.Add(rootMarker.Clone());\n            this.PolarConnections.Add(innerMarker.Clone());\n            this.PolarConnections.Add(new PolarMarker());\n\n            GenerateMarkers(innerNode, innerMarker, 2, 60);\n        }\n\n        // grouping all tree markers by their node level\n        PolarMarkersByLevel = new Dictionary<double, List<PolarMarker>>();\n        foreach (var marker in this.PolarMarkers)\n        {\n            if (!this.PolarMarkersByLevel.ContainsKey(marker.Level))\n            {\n                this.PolarMarkersByLevel.Add(marker.Level, new List<PolarMarker>());\n            }\n\n            this.PolarMarkersByLevel[marker.Level].Add(marker);\n        }\n    }\n\n    void GenerateMarkers(TreeNode innerNode, PolarMarker innerMarker, double level, double angelSpan)\n    {\n        var outerInterval = 0.0;\n        var outerAngle = 0.0;\n        if (innerNode.Children.Count % 2 == 0)\n        {\n            outerInterval = (angelSpan / (innerNode.Children.Count)) / 2.0;\n            outerAngle = innerMarker.Angle - (outerInterval * innerNode.Children.Count);\n        }\n        else\n        {\n            outerInterval = (angelSpan / (innerNode.Children.Count));\n            outerAngle = innerMarker.Angle - (outerInterval * ((innerNode.Children.Count - 1) / 2.0));\n        }\n\n        for (int o = 0; o < innerNode.Children.Count; o++)\n        {\n            var outerNode = innerNode.Children[o];\n\n            var outerStep =  0.0;\n            if (innerNode.Children.Count % 2 == 0)\n                outerStep = (o * outerInterval * 2) + outerInterval;\n            else\n                outerStep = (o * (outerInterval));\n\n            var outerMarker = new PolarMarker { Label = outerNode.Label };\n            outerMarker.Parent = innerMarker;\n            outerMarker.Angle = outerAngle + outerStep;\n            outerMarker.Level = level;\n            outerMarker.Fill = ColorMapping[outerMarker.Level];\n\n            this.PolarMarkers.Add(outerMarker);\n\n            this.PolarConnections.Add(innerMarker.Clone());\n            this.PolarConnections.Add(outerMarker.Clone());\n            this.PolarConnections.Add(new PolarMarker());\n\n            if (outerNode.Children.Count > 0)\n                GenerateMarkers(outerNode, outerMarker, level + 1, angelSpan / 3.0);\n\n        }\n    }\n\n    protected override void OnAfterRender(bool firstRender)\n    {\n        if (this.Chart != null && this.Legend != null && !firstRender) {\n            this.Chart.Legend = this.Legend;\n        }\n    }\n\n    public class TreeNode\n    {\n        public List<TreeNode> Children { get; set; }\n        public TreeNode Parent { get; set; }\n        public string Label { get; set; }\n        public double Value { get; set; }\n\n        public TreeNode()\n        {\n            Children = new List<TreeNode>();\n        }\n    }\n\n    public class PolarMarker\n    {\n        public PolarMarker Parent { get; set; }\n\n        public double Angle { get; set; }\n        public double Level { get; set; }\n\n        public double Radius { get; set; }\n        public string Fill { get; set; }\n        public string Outline { get; set; }\n        public int Thickness { get; set; }\n\n        public string Label { get; set; }\n        public string LabelColor { get; set; }\n        public int    LabelSize { get; set; }\n\n        public PolarMarker()\n        {\n            Level = double.NaN;\n            Angle = double.NaN;\n            LabelColor = \"white\";\n            LabelSize = 12;\n\n            Radius = 12;\n            Fill = \"black\";\n            Outline = \"black\";\n        }\n\n        public PolarMarker Clone()\n        {\n            var clone = new PolarMarker();\n            clone.Level = this.Level;\n            clone.Angle = this.Angle;\n            return clone;\n        }\n    }\n\n}",
    "isMain": true,
    "fileExtension": "razor",
    "fileHeader": "razor"
  },
  {
    "hasRelativeAssetsUrls": false,
    "path": "../../samples/charts/data-chart/network-polar-chart/Program.cs",
    "content": "using System;\nusing System.Net.Http;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing System.Text;\nusing Microsoft.AspNetCore.Components.WebAssembly.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing IgniteUI.Blazor.Controls; // for registering Ignite UI modules\n\nnamespace Infragistics.Samples\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var builder = WebAssemblyHostBuilder.CreateDefault(args);\n            builder.RootComponents.Add<App>(\"app\");\n            builder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });\n            // registering Ignite UI modules\n            builder.Services.AddIgniteUIBlazor(\n                 typeof(IgbLegendModule),\n                 typeof(IgbNumberAbbreviatorModule),\n                 typeof(IgbDataChartCoreModule),\n                 typeof(IgbDataChartInteractivityModule),\n                 typeof(IgbDataChartPolarModule),\n                 typeof(IgbDataChartPolarCoreModule)\n            );\n            await builder.Build().RunAsync();\n        }\n    }\n}",
    "isMain": true,
    "fileExtension": "cs",
    "fileHeader": "MODULES"
  },
  {
    "hasRelativeAssetsUrls": false,
    "path": "../../samples/charts/data-chart/network-polar-chart/wwwroot/DataChartNetworkPolarChartScripts.js",
    "content": "ï»¿function onNetworkPolarChartMouseEnter(o, e) {\r\n\r\n    if (e.series.tooltipTemplate === null ||\r\n        e.series.tooltipTemplate === undefined) {\r\n        e.series.tooltipTemplate = onNetworkPolarChartTooltip;\r\n        console.log(\"onNetworkPolarChartMouseEnter\");\r\n    }\r\n}\r\nigRegisterScript(\"onNetworkPolarChartMouseEnter\", onNetworkPolarChartMouseEnter, false);\r\n\r\nfunction onNetworkPolarChartTooltip(context) {\r\n\r\n    if (!context) return null;\r\n\r\n    var dataItem = context.item;\r\n    if (!dataItem) return null;\r\n\r\n    var tooltip = document.createElement(\"div\");\r\n    tooltip.className = \"ui-tooltip-content\";\r\n\r\n    var div = document.createElement(\"div\");\r\n    div.innerHTML = \"Node: \" + dataItem.Label;\r\n    div.style.color = dataItem.Fill;\r\n    tooltip.appendChild(div);\r\n\r\n    div = document.createElement(\"div\");\r\n    div.innerHTML = \"Level: \" + dataItem.Radius;\r\n    tooltip.appendChild(div);\r\n\r\n    return tooltip;\r\n}\r\n\r\nfunction onNetworkPolarChartMarker(o, e) {\r\n\r\n    var desiredSize = 45;\r\n    return {\r\n        measure: function (measureInfo) {\r\n            measureInfo.width = desiredSize;\r\n            measureInfo.height = desiredSize;\r\n        },\r\n\r\n        render: function (renderInfo) {\r\n            var ctx = renderInfo.context;\r\n            if (renderInfo.isHitTestRender) {\r\n                ctx.fillStyle = renderInfo.data.actualItemBrush.fill;\r\n            } else {\r\n                ctx.fillStyle = \"black\";\r\n            }\r\n\r\n            var halfWidth  = Math.round(renderInfo.availableWidth / 2.0);\r\n            var halfHeight = Math.round(renderInfo.availableHeight / 2.0);\r\n\r\n            var cx = renderInfo.xPosition;\r\n            var cy = renderInfo.yPosition;\r\n\r\n            var x = renderInfo.xPosition - halfWidth;\r\n            var y = renderInfo.yPosition - halfHeight;\r\n\r\n            if (renderInfo.isHitTestRender) {\r\n                ctx.fillRect(x, y, renderInfo.availableWidth, renderInfo.availableHeight);\r\n\r\n            } else {\r\n\r\n                var data = renderInfo.data;\r\n\r\n                var viewportHeight = renderInfo.passInfo.viewportHeight;\r\n                var viewportRatio = viewportHeight / 200.0;\r\n                var markerSize = viewportRatio * desiredSize;\r\n                var markerRadius = Math.min(50, data.item.Radius);\r\n                ctx.strokeStyle = data.item.Outline;\r\n                ctx.fillStyle   = data.item.Fill;\r\n                ctx.lineWidth   = data.item.Thickness;\r\n                ctx.beginPath();\r\n                ctx.arc(cx, cy, markerRadius, 0, 2 * Math.PI);\r\n                ctx.stroke();\r\n                ctx.fill();\r\n\r\n                var text = data.item.Label.toString();\r\n                // var textSize = Math.round(viewportRatio * 10);\r\n                var textSize = Math.max(10, data.item.LabelSize);\r\n                ctx.font = \"normal \" + textSize + \"px Verdana\";\r\n                ctx.textBaseline = \"middle\";\r\n                ctx.textAlign = \"center\";\r\n                ctx.fillStyle = data.item.LabelColor;\r\n                ctx.fillText(text, cx, cy);\r\n            }\r\n        }\r\n    }\r\n}\r\nigRegisterScript(\"onNetworkPolarChartMarker\", onNetworkPolarChartMarker, true);",
    "isMain": true,
    "fileExtension": "js",
    "fileHeader": "js"
  },
  {
    "hasRelativeAssetsUrls": false,
    "path": "../../samples/charts/data-chart/network-polar-chart/wwwroot/index.css",
    "content": "/* \r\nCSS styles are loaded from the shared CSS file located at:\r\nhttps://static.infragistics.com/xplatform/css/samples/\r\n*/",
    "isMain": true,
    "fileExtension": "css",
    "fileHeader": "css"
  }
]
}